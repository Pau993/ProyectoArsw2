class a{constructor(){this.x=0,this.y=0,this.speed=0,this.direction="down",this.collisionOn=!1,this.solidArea={x:0,y:0,width:48,height:48},this.solidAreaDefaultX=this.solidArea.x,this.solidAreaDefaultY=this.solidArea.y,this.images={up:null,down:null,left:null,right:null,front:null,upLoaded:null,downLoaded:null,leftLoaded:null,rightLoaded:null,upLoadedTwo:null,downLoadedTwo:null,leftLoadedTwo:null,rightLoadedTwo:null}}async loadImage(e,t){return new Promise(s=>{const i=new Image;i.onload=()=>{this.images[e]=i,s()},i.src=t})}draw(e,t){const s=this.images[this.direction];s&&e.drawImage(s,this.x,this.y,t,t)}}class h extends a{constructor(e,t,s){super(),this.x=100,this.y=100,this.speed=4,this.direction="down",this.hasPerson=0,this.tileSize=s,this.solidArea={x:10,y:10,width:45,height:60},this.solidAreaDefaultX=this.solidArea.x,this.solidAreaDefaultY=this.solidArea.y}async loadImages(){const e=[{key:"up",path:"/player/aliUp.png"},{key:"down",path:"/player/down.png"},{key:"left",path:"/player/AlimentadorIzq.png"},{key:"right",path:"/player/AlimentadorDer.png"},{key:"upLoadedTwo",path:"/player/TransmiUp.png"},{key:"downLoadedTwo",path:"/player/TransmiDown.png"},{key:"leftLoadedTwo",path:"/player/TransmiIzq.png"},{key:"rightLoadedTwo",path:"/player/TransmiDer.png"},{key:"upLoaded",path:"/player/SitpUp.png"},{key:"downLoaded",path:"/player/SitpDown.png"},{key:"leftLoaded",path:"/player/SitpIzq.png"},{key:"rightLoaded",path:"/player/SitpDer.png"}];await Promise.all(e.map(({key:t,path:s})=>this.loadImage(t,s)))}getCurrentImage(){return this.hasPerson>=5?this.images[this.direction+"LoadedTwo"]:this.hasPerson>=3?this.images[this.direction+"Loaded"]:this.images[this.direction]}draw(e){const t=this.getCurrentImage();t&&e.drawImage(t,this.x,this.y,this.tileSize,this.tileSize)}update(e,t,s){this.collisionOn=!1;let i=!1;if(e.up?(this.direction="up",i=!0):e.down?(this.direction="down",i=!0):e.left?(this.direction="left",i=!0):e.right&&(this.direction="right",i=!0),i){t.checkTile(this);const o=t.checkObject(this,s,!0);if(o!==999&&this.pickUpObject(o,s),!this.collisionOn)switch(this.direction){case"up":this.y-=this.speed;break;case"down":this.y+=this.speed;break;case"left":this.x-=this.speed;break;case"right":this.x+=this.speed;break}}}pickUpObject(e,t){e!==999&&t[e]&&(t[e].name==="person"?(this.hasPerson++,t[e]=null):t[e].name==="obstacles"&&(this.hasPerson--,t[e]=null))}}class n{static ws=new WebSocket("ws://localhost:8080/jugador");static RECONNECT_DELAY=5e3;static MAX_RETRIES=3;constructor(){this.socket=null,this.isConnected=!1,this.onPlayersUpdate=null,this.connectionAttempts=0,this.pendingMessages=[],this.sessionId=null}connect(){if(this.connectionAttempts>=n.MAX_RETRIES){console.error("Max reconnection attempts reached");return}try{this.socket&&this.socket.close(),console.log(`Connecting to WebSocket... (Attempt ${this.connectionAttempts+1})`),this.socket=new WebSocket(`ws://${n.host}/game`),this.socket.onopen=()=>{console.log("WebSocket Connected"),this.isConnected=!0,this.connectionAttempts=0,this.processQueuedMessages()},this.socket.onmessage=e=>{this.handleMessage(e)},this.socket.onclose=e=>{this.handleClose(e)},this.socket.onerror=e=>{this.handleError(e)}}catch(e){console.error("Connection error:",e),this.handleReconnect()}}handleMessage(e){try{const t=JSON.parse(e.data);if(t.error){console.error("Server error:",t.error);return}this.onPlayersUpdate&&this.onPlayersUpdate(t)}catch(t){console.error("Error parsing message:",t)}}handleClose(e){this.isConnected=!1,console.log(`Connection closed: ${e.code}`),e.code!==1e3&&this.handleReconnect()}handleError(e){console.error("WebSocket Error:",e),this.isConnected=!1}processQueuedMessages(){for(;this.pendingMessages.length>0;){const e=this.pendingMessages.shift();this.sendPlayerData(e)}}sendPlayerData(e){if(!this.isConnected||!this.socket){this.pendingMessages.push(e);return}try{this.socket.send(JSON.stringify(e))}catch(t){console.error("Error sending player data:",t),this.pendingMessages.push(e),this.handleReconnect()}}sendPlayerPosition(e){const t={x:e.x,y:e.y,direction:e.direction,hasPerson:e.hasPerson};this.sendPlayerData(t)}handleReconnect(){if(this.connectionAttempts++,this.connectionAttempts<n.MAX_RETRIES){const e=n.RECONNECT_DELAY*this.connectionAttempts;console.log(`Reconnecting in ${e/1e3}s...`),setTimeout(()=>this.connect(),e)}}setPlayersUpdateCallback(e){this.onPlayersUpdate=e}disconnect(){this.socket&&(this.socket.close(1e3,"Client disconnecting"),this.socket=null,this.isConnected=!1,this.connectionAttempts=0)}}export{h as P,n as W};
